{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport { createApp } from 'vue';\nimport { createStore } from 'vuex';\nimport { createRouter, createWebHistory } from 'vue-router';\nimport App from './App.vue';\nimport '@fortawesome/fontawesome-free/css/all.css';\n\n// Create store\nconst store = createStore({\n  state() {\n    return {\n      token: localStorage.getItem('spotify_token') || null,\n      refreshToken: localStorage.getItem('spotify_refresh_token') || null,\n      currentTrack: null,\n      isPlaying: false\n    };\n  },\n  mutations: {\n    setToken(state, token) {\n      state.token = token;\n      localStorage.setItem('spotify_token', token);\n    },\n    setRefreshToken(state, refreshToken) {\n      state.refreshToken = refreshToken;\n      localStorage.setItem('spotify_refresh_token', refreshToken);\n    },\n    setCurrentTrack(state, track) {\n      state.currentTrack = track;\n    },\n    setIsPlaying(state, isPlaying) {\n      state.isPlaying = isPlaying;\n    },\n    logout(state) {\n      state.token = null;\n      state.refreshToken = null;\n      state.currentTrack = null;\n      state.isPlaying = false;\n      localStorage.removeItem('spotify_token');\n      localStorage.removeItem('spotify_refresh_token');\n    }\n  },\n  actions: {\n    async fetchCurrentTrack({\n      commit,\n      state,\n      dispatch\n    }) {\n      if (!state.token) return;\n      try {\n        const response = await fetch('https://api.spotify.com/v1/me/player/currently-playing', {\n          headers: {\n            'Authorization': `Bearer ${state.token}`\n          }\n        });\n        if (response.status === 204) {\n          // No track currently playing\n          commit('setCurrentTrack', null);\n          commit('setIsPlaying', false);\n          return;\n        }\n        if (!response.ok) {\n          throw new Error('Failed to fetch current track');\n        }\n        const data = await response.json();\n        commit('setCurrentTrack', data.item);\n        commit('setIsPlaying', data.is_playing);\n      } catch (error) {\n        console.error('Error fetching current track:', error);\n        // Handle token expiration\n        if (error.response && error.response.status === 401) {\n          await dispatch('refreshAccessToken');\n        }\n      }\n    },\n    async refreshAccessToken({\n      commit,\n      state\n    }) {\n      if (!state.refreshToken) return;\n      const CLIENT_ID = process.env.VUE_APP_SPOTIFY_CLIENT_ID;\n      // In a real app, you'd handle this server-side to protect your client secret\n      const CLIENT_SECRET = process.env.VUE_APP_SPOTIFY_CLIENT_SECRET;\n      try {\n        const response = await fetch('https://accounts.spotify.com/api/token', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Authorization': 'Basic ' + btoa(CLIENT_ID + ':' + CLIENT_SECRET)\n          },\n          body: new URLSearchParams({\n            grant_type: 'refresh_token',\n            refresh_token: state.refreshToken\n          })\n        });\n        if (!response.ok) {\n          throw new Error('Failed to refresh token');\n        }\n        const data = await response.json();\n        commit('setToken', data.access_token);\n        if (data.refresh_token) {\n          commit('setRefreshToken', data.refresh_token);\n        }\n      } catch (error) {\n        console.error('Error refreshing token:', error);\n        commit('logout');\n      }\n    }\n  }\n});\n\n// Create router\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [{\n    path: '/',\n    name: 'Home',\n    component: () => import('./components/NowPlaying.vue'),\n    meta: {\n      requiresAuth: true\n    }\n  }, {\n    path: '/login',\n    name: 'Login',\n    component: () => import('./components/LoginPage.vue')\n  }, {\n    path: '/callback',\n    name: 'Callback',\n    component: () => import('./components/CallbackPage.vue')\n  }]\n});\n\n// Navigation guard\nrouter.beforeEach((to, from, next) => {\n  const isAuthenticated = store.state.token !== null;\n  if (to.matched.some(record => record.meta.requiresAuth) && !isAuthenticated) {\n    next({\n      name: 'Login'\n    });\n  } else {\n    next();\n  }\n});\nconst app = createApp(App);\napp.use(store);\napp.use(router);\napp.mount('#app');","map":{"version":3,"names":["createApp","createStore","createRouter","createWebHistory","App","store","state","token","localStorage","getItem","refreshToken","currentTrack","isPlaying","mutations","setToken","setItem","setRefreshToken","setCurrentTrack","track","setIsPlaying","logout","removeItem","actions","fetchCurrentTrack","commit","dispatch","response","fetch","headers","status","ok","Error","data","json","item","is_playing","error","console","refreshAccessToken","CLIENT_ID","process","env","VUE_APP_SPOTIFY_CLIENT_ID","CLIENT_SECRET","VUE_APP_SPOTIFY_CLIENT_SECRET","method","btoa","body","URLSearchParams","grant_type","refresh_token","access_token","router","history","routes","path","name","component","meta","requiresAuth","beforeEach","to","from","next","isAuthenticated","matched","some","record","app","use","mount"],"sources":["C:/Users/menof/OneDrive/Desktop/Now Playing/now-playing/src/main.js"],"sourcesContent":["import { createApp } from 'vue'\nimport { createStore } from 'vuex'\nimport { createRouter, createWebHistory } from 'vue-router'\nimport App from './App.vue'\nimport '@fortawesome/fontawesome-free/css/all.css'\n\n\n// Create store\nconst store = createStore({\n  state() {\n    return {\n      token: localStorage.getItem('spotify_token') || null,\n      refreshToken: localStorage.getItem('spotify_refresh_token') || null,\n      currentTrack: null,\n      isPlaying: false\n    }\n  },\n  mutations: {\n    setToken(state, token) {\n      state.token = token\n      localStorage.setItem('spotify_token', token)\n    },\n    setRefreshToken(state, refreshToken) {\n      state.refreshToken = refreshToken\n      localStorage.setItem('spotify_refresh_token', refreshToken)\n    },\n    setCurrentTrack(state, track) {\n      state.currentTrack = track\n    },\n    setIsPlaying(state, isPlaying) {\n      state.isPlaying = isPlaying\n    },\n    logout(state) {\n      state.token = null\n      state.refreshToken = null\n      state.currentTrack = null\n      state.isPlaying = false\n      localStorage.removeItem('spotify_token')\n      localStorage.removeItem('spotify_refresh_token')\n    }\n  },\n  actions: {\n    async fetchCurrentTrack({ commit, state, dispatch }) {\n      if (!state.token) return\n      \n      try {\n        const response = await fetch('https://api.spotify.com/v1/me/player/currently-playing', {\n          headers: {\n            'Authorization': `Bearer ${state.token}`\n          }\n        })\n        \n        if (response.status === 204) {\n          // No track currently playing\n          commit('setCurrentTrack', null)\n          commit('setIsPlaying', false)\n          return\n        }\n        \n        if (!response.ok) {\n          throw new Error('Failed to fetch current track')\n        }\n        \n        const data = await response.json()\n        commit('setCurrentTrack', data.item)\n        commit('setIsPlaying', data.is_playing)\n      } catch (error) {\n        console.error('Error fetching current track:', error)\n        // Handle token expiration\n        if (error.response && error.response.status === 401) {\n          await dispatch('refreshAccessToken')\n        }\n      }\n    },\n    async refreshAccessToken({ commit, state }) {\n      if (!state.refreshToken) return\n      \n      const CLIENT_ID = process.env.VUE_APP_SPOTIFY_CLIENT_ID\n      // In a real app, you'd handle this server-side to protect your client secret\n      const CLIENT_SECRET = process.env.VUE_APP_SPOTIFY_CLIENT_SECRET\n      \n      try {\n        const response = await fetch('https://accounts.spotify.com/api/token', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Authorization': 'Basic ' + btoa(CLIENT_ID + ':' + CLIENT_SECRET)\n          },\n          body: new URLSearchParams({\n            grant_type: 'refresh_token',\n            refresh_token: state.refreshToken\n          })\n        })\n        \n        if (!response.ok) {\n          throw new Error('Failed to refresh token')\n        }\n        \n        const data = await response.json()\n        commit('setToken', data.access_token)\n        if (data.refresh_token) {\n          commit('setRefreshToken', data.refresh_token)\n        }\n      } catch (error) {\n        console.error('Error refreshing token:', error)\n        commit('logout')\n      }\n    }\n  }\n})\n\n// Create router\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    {\n      path: '/',\n      name: 'Home',\n      component: () => import('./components/NowPlaying.vue'),\n      meta: { requiresAuth: true }\n    },\n    {\n      path: '/login',\n      name: 'Login',\n      component: () => import('./components/LoginPage.vue')\n    },\n    {\n      path: '/callback',\n      name: 'Callback',\n      component: () => import('./components/CallbackPage.vue')\n    }\n  ]\n})\n\n// Navigation guard\nrouter.beforeEach((to, from, next) => {\n  const isAuthenticated = store.state.token !== null\n  \n  if (to.matched.some(record => record.meta.requiresAuth) && !isAuthenticated) {\n    next({ name: 'Login' })\n  } else {\n    next()\n  }\n})\n\nconst app = createApp(App)\napp.use(store)\napp.use(router)\napp.mount('#app')"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}